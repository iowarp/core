#!/usr/bin/env python3
"""
Update file headers in IOWarp Core codebase.

This script updates C/C++ source and header files to use the correct
IOWarp BSD 3-Clause license header, replacing any old Hermes headers.
"""

import os
import re
import argparse
from pathlib import Path
from typing import List, Tuple

# Header template
HEADER_TEMPLATE = """/*
 * Copyright (c) 2024, Gnosis Research Center, Illinois Institute of Technology
 * All rights reserved.
 *
 * This file is part of IOWarp Core.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

"""

# Directories to skip
SKIP_DIRS = {
    'build', 'venv', '.git', '__pycache__', 'third_party',
    'external', '_deps', 'CMakeFiles', 'Testing',
    '.vscode', '.idea', 'dist', 'node_modules'
}

# File patterns to skip
SKIP_PATTERNS = [
    r'.*autogen.*',  # Autogenerated files
    r'.*\.pb\..*',   # Protobuf generated files
    r'.*_generated\..*',  # Generated files
]

# File extensions to process
EXTENSIONS = {'.h', '.hpp', '.hh', '.c', '.cc', '.cpp', '.cxx'}


def should_skip_file(filepath: Path) -> bool:
    """Check if file should be skipped."""
    # Skip if in excluded directory
    for part in filepath.parts:
        if part in SKIP_DIRS:
            return True

    # Skip if matches excluded pattern
    filepath_str = str(filepath)
    for pattern in SKIP_PATTERNS:
        if re.match(pattern, filepath_str):
            return True

    return False


def remove_existing_header(content: str) -> Tuple[str, bool]:
    """
    Remove existing C-style header comments from file content.
    Returns (cleaned_content, had_header).
    """
    # Pattern to match C-style block comments at the start of the file
    # This handles multi-line comments that may contain copyright, license info, etc.
    pattern = r'^(/\*[\s\S]*?\*/\s*)'

    match = re.match(pattern, content)
    if match:
        # Check if this looks like a header (contains copyright, license, etc.)
        header_text = match.group(1).lower()
        if any(keyword in header_text for keyword in
               ['copyright', 'license', 'redistribution', 'hermes', 'permission']):
            # Remove the header
            cleaned = content[match.end():]
            return cleaned, True

    return content, False


def add_header(content: str) -> str:
    """Add IOWarp header to file content."""
    return HEADER_TEMPLATE + content


def process_file(filepath: Path, dry_run: bool = False) -> bool:
    """
    Process a single file to update its header.
    Returns True if file was modified.
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            original_content = f.read()
    except UnicodeDecodeError:
        print(f"  ‚ö†Ô∏è  Skipping {filepath} (encoding error)")
        return False
    except Exception as e:
        print(f"  ‚ùå Error reading {filepath}: {e}")
        return False

    # Remove existing header
    cleaned_content, had_header = remove_existing_header(original_content)

    # Add new header
    new_content = add_header(cleaned_content)

    # Check if content changed
    if new_content == original_content:
        return False

    if dry_run:
        action = "Replace" if had_header else "Add"
        print(f"  [{action}] {filepath}")
        return True

    # Write updated content
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(new_content)
        action = "Replaced" if had_header else "Added"
        print(f"  ‚úÖ [{action}] {filepath}")
        return True
    except Exception as e:
        print(f"  ‚ùå Error writing {filepath}: {e}")
        return False


def find_files(root_dir: Path) -> List[Path]:
    """Find all C/C++ files to process."""
    files = []
    for ext in EXTENSIONS:
        for filepath in root_dir.rglob(f'*{ext}'):
            if not should_skip_file(filepath):
                files.append(filepath)
    return sorted(files)


def main():
    parser = argparse.ArgumentParser(
        description='Update file headers in IOWarp Core codebase'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be changed without modifying files'
    )
    parser.add_argument(
        '--path',
        type=str,
        default='.',
        help='Root directory to process (default: current directory)'
    )
    parser.add_argument(
        '--file',
        type=str,
        help='Process a single file instead of entire directory'
    )

    args = parser.parse_args()

    if args.file:
        # Process single file
        filepath = Path(args.file)
        if not filepath.exists():
            print(f"‚ùå File not found: {filepath}")
            return 1

        print(f"Processing file: {filepath}")
        if args.dry_run:
            print("(DRY RUN - no files will be modified)")

        modified = process_file(filepath, dry_run=args.dry_run)
        if modified:
            print("\n‚úÖ File would be modified" if args.dry_run else "\n‚úÖ File updated")
        else:
            print("\n‚úì File already has correct header")
        return 0

    # Process directory
    root_dir = Path(args.path).resolve()
    if not root_dir.exists():
        print(f"‚ùå Directory not found: {root_dir}")
        return 1

    print(f"Searching for C/C++ files in: {root_dir}")
    files = find_files(root_dir)
    print(f"Found {len(files)} files to process\n")

    if args.dry_run:
        print("DRY RUN MODE - No files will be modified\n")

    modified_count = 0
    for filepath in files:
        if process_file(filepath, dry_run=args.dry_run):
            modified_count += 1

    print(f"\n{'='*60}")
    print(f"Summary:")
    print(f"  Total files: {len(files)}")
    print(f"  Modified: {modified_count}")
    print(f"  Unchanged: {len(files) - modified_count}")

    if args.dry_run:
        print(f"\nüí° Run without --dry-run to apply changes")
    else:
        print(f"\n‚úÖ Header update complete!")

    return 0


if __name__ == '__main__':
    exit(main())
