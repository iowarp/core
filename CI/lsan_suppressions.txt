# LSAN suppression list for IOWarp Core ASan/LSan runs.
# LeakSanitizer suppresses reports whose call stacks contain any of
# the patterns below. Use these only for leaks that are architectural
# (i.e. intentional lifetime-until-exit) or come from third-party
# libraries that we do not control.

# ---------------------------------------------------------------------------
# ZMQ internal allocations (routing table, mechanism metadata, etc.)
# ZeroMQ allocates internal state in libzmq.so that is cleaned up at
# zmq_ctx_destroy() time, but not always before process exit.
# ---------------------------------------------------------------------------
leak:libzmq.so

# ---------------------------------------------------------------------------
# Chi runtime: RunContext leaks on shutdown
# When the runtime shuts down, some tasks may still be in-flight. Their
# RunContext (unique_ptr<chi::RunContext> created in IpcManager::BeginTask
# or Worker::BeginTask) is freed only when the task reaches DelTask.
# Stopping worker threads before draining the queue leaves RunContexts
# unreachable.
# ---------------------------------------------------------------------------
leak:chi::Worker::BeginTask
leak:chi::IpcManager::BeginTask

# ---------------------------------------------------------------------------
# Chi runtime: large IPC buffer allocations in tests
# Tests that call IpcManager::AllocateBuffer() with sizes â‰¥ 600 MB are
# intentionally exercising IncreaseMemory() and do not always call
# FreeBuffer() afterwards. The OS reclaims these allocations on exit.
# ---------------------------------------------------------------------------
leak:chi::IpcManager::AllocateBuffer

# ---------------------------------------------------------------------------
# Chi runtime: IpcManager::NewTask allocations not freed on shutdown
# Tasks allocated with NewTask() are normally freed by DelTask().
# During abnormal shutdown (port-conflict failures, timeout), tasks may
# remain allocated. Suppress the NewTask allocation site to avoid
# spurious reports from infrastructure failures.
# ---------------------------------------------------------------------------
leak:chi::IpcManager::NewTask

# ---------------------------------------------------------------------------
# Chi runtime: MOD_NAME TestLargeOutput task data vector
# The TestLargeOutput coroutine intentionally fills task->data_ with 1 MB
# of test data. If the runtime shuts down before the task is fully cleaned
# up, the std::vector storage appears as a leak.
# ---------------------------------------------------------------------------
leak:TestLargeOutput

# ---------------------------------------------------------------------------
# Chi runtime: Chimaera::ServerInit internal allocations
# ServerInit allocates runtime-lifetime objects (config, singletons, queues)
# that persist until process exit. These are architectural and not leaked.
# ---------------------------------------------------------------------------
leak:chi::Chimaera::ServerInit

# ---------------------------------------------------------------------------
# Chi runtime: Task::Serialize pool config string allocations
# Serialization of PoolConfig (including its IPC string fields) may allocate
# buffers that are freed only when the task is destructed. Tasks freed via
# IPC path bypass C++ destructors, leaving these buffers unreachable.
# ---------------------------------------------------------------------------
leak:chi::Task::Serialize

# ---------------------------------------------------------------------------
# bdev: AllocateBlocks block-list vector growth
# bdev::Runtime::AllocateBlocks pushes Block entries into a priv::vector.
# When the runtime shuts down before all block-lists are freed, the internal
# vector buffer shows as a leak.
# ---------------------------------------------------------------------------
leak:AllocateBlocks

# ---------------------------------------------------------------------------
# CAE: ParseOmni string allocations
# CAE ParseOmni assigns std::string fields into IPC priv::string members.
# On runtime shutdown these task fields are not always destructed properly.
# ---------------------------------------------------------------------------
leak:ParseOmni

# ---------------------------------------------------------------------------
# CTE: GetContainedBlobs std::vector<std::string> push_back
# CTE's GetContainedBlobs builds a local std::vector<std::string> result;
# if the task is freed via IPC path, the vector's heap buffer leaks.
# ---------------------------------------------------------------------------
leak:GetContainedBlobs

# ---------------------------------------------------------------------------
# CTE: BlobQuery std::vector<std::string> push_back
# CTE's BlobQuery builds a local std::vector<std::string> blob_names result;
# if the runtime shuts down before the task completes, the string buffers leak.
# ---------------------------------------------------------------------------
leak:BlobQuery

# ---------------------------------------------------------------------------
# Chi runtime: per-thread TaskCounter in CreateTaskId()
# chi::CreateTaskId() allocates a 4-byte TaskCounter via new and stores it
# in thread-local storage using HSHM_THREAD_MODEL->SetTls(). Worker threads
# created with std::thread may not invoke the TLS destructor on exit, leaving
# the counter unreachable. This is an architectural TLS lifetime pattern;
# the OS reclaims the allocation on process exit.
# ---------------------------------------------------------------------------
leak:chi::CreateTaskId

# ---------------------------------------------------------------------------
# Chi modules: new_chimod container objects leak on server shutdown
# ModuleManager::CreateContainer() calls new_chimod() to instantiate each
# ChiMod object (CAE, CTE, bdev, etc.) with operator new. On server shutdown
# the runtime does not delete these container objects, leaving them unreachable.
# ---------------------------------------------------------------------------
leak:new_chimod

# ---------------------------------------------------------------------------
# bdev module: 512 MB RAM buffer allocated in bdev::Runtime::Create()
# The bdev module allocates its backing RAM buffer with `operator new[]` in
# bdev_runtime.cc::Create(). This buffer persists for the module lifetime
# (until process exit). LSAN sees it as an indirect leak when the bdev module
# container pointer is not freed on server shutdown.
# ---------------------------------------------------------------------------
leak:bdev/src/bdev_runtime.cc

# ---------------------------------------------------------------------------
# CTE core module: internal hash-map allocations in wrp_cte::core::Create()
# The CTE Create coroutine initialises several unordered_map_ll instances
# (blob map, tag map, blob-name map) in context-transfer-engine/core/
# src/core_runtime.cc. These are runtime-lifetime objects that the server
# does not explicitly destroy before exit.
# ---------------------------------------------------------------------------
leak:context-transfer-engine/core/src/core_runtime.cc

# ---------------------------------------------------------------------------
# CAE core module: shared_ptr<CTE::Client> allocated in wrp_cae::core::Create()
# The CAE Create coroutine allocates a shared_ptr to a wrp_cte::core::Client
# object (for accessing the CTE service). This shared_ptr control block is
# allocated in context-assimilation-engine/core/src/core_runtime.cc and
# persists for the module's lifetime.
# ---------------------------------------------------------------------------
leak:context-assimilation-engine/core/src/core_runtime.cc

# ---------------------------------------------------------------------------
# Chi runtime: Container::Init() name string allocation
# chi::Container::Init() assigns the module pool name to a std::string member
# (Container::name_). When the module container object is not explicitly
# destroyed on server shutdown, this std::string heap allocation leaks.
# All chi module containers (bdev, CTE, CAE, admin) go through this path.
# ---------------------------------------------------------------------------
leak:chi::Container::Init

# ---------------------------------------------------------------------------
# Chi runtime: LocalLoadTaskArchive::bulk IPC buffer allocations in tests
# LocalLoadTaskArchive::bulk() allocates a small IPC ShmPtr buffer to hold
# deserialized task data (e.g. WriteTask data, ReadTask data, GetBlobTask data).
# In the autogen-coverage tests, tasks are constructed and serialized without
# a paired destruction path, so these 16-byte allocations are never freed.
# This is a test-infrastructure artefact; the OS reclaims on process exit.
# ---------------------------------------------------------------------------
leak:chi::LocalLoadTaskArchive::bulk

# ---------------------------------------------------------------------------
# CTE core module: coroutine frame allocation in autogen Run dispatch
# wrp_cte::core::Runtime::Run() is a C++20 coroutine. Each task invocation
# allocates a coroutine frame (~1640 bytes) at the first co_await. If the
# chimaera server shuts down while a CTE Run coroutine is suspended
# (task still in-flight), the frame is never resumed and thus never freed.
# This is the same architectural shutdown-before-drain pattern as BeginTask;
# the allocation site lands in the autogen dispatch file, not core_runtime.cc.
# ---------------------------------------------------------------------------
leak:context-transfer-engine/core/src/autogen/core_lib_exec.cc

# ---------------------------------------------------------------------------
# bdev / ZMQ transport: block-data vectors allocated during RecvBulks
# hshm::lbm::ZeroMqTransport::RecvBulks<chi::LoadTaskArchive>() receives a
# ZMQ multi-part message and deserialises bdev Block entries into heap vectors
# (via cereal/msgpack) before passing them to LoadTask / AllocLoadTask.
# If the server shuts down before the task completes, the interim heap buffer
# (allocated in zmq_transport.h, NOT inside libzmq.so) remains unreachable.
# The existing `leak:libzmq.so` rule does not cover this site because the
# allocation is in our wrapper code, not in the ZMQ shared library itself.
# ---------------------------------------------------------------------------
leak:hshm::lbm::ZeroMqTransport::RecvBulks

# ---------------------------------------------------------------------------
# bdev module: Block vector deserialized in LoadTask / AllocLoadTask
# bdev::Runtime::LoadTask() and AllocLoadTask() (autogen bdev_lib_exec.cc)
# deserialise incoming bdev tasks (WriteTask, ReadTask, etc.) from the
# chi::LoadTaskArchive. This calls LoadTaskArchive::operator>> which resizes
# a hshm::priv::vector<bdev::Block> on the malloc heap. If the server shuts
# down while bdev tasks are still in-flight, these block vectors are never
# freed (the task is freed via IPC path that bypasses C++ destructors).
# ---------------------------------------------------------------------------
leak:bdev/src/autogen/bdev_lib_exec.cc

# ---------------------------------------------------------------------------
# Chi runtime: IpcManager::RouteGlobal PoolQuery vector copy for in-flight tasks
# When IpcManager::Send() routes a task to a remote module, RouteGlobal()
# copies the caller's std::vector<PoolQuery> into a temporary used for
# routing decisions. If the task is in-flight when the server shuts down,
# this copied PoolQuery vector is never freed. The leak manifests as an
# indirect leak reachable only through the (suppressed) task allocation.
# ---------------------------------------------------------------------------
leak:chi::IpcManager::RouteGlobal

# ---------------------------------------------------------------------------
# Chi runtime: admin::Runtime::SendIn coroutine sub-allocations
# admin::Runtime::SendIn() (admin_runtime.cc) is a coroutine that routes
# tasks from local clients to remote module servers via ZMQ. It allocates
# intermediate buffers for serialisation / transport framing. When the server
# shuts down while a SendIn coroutine is suspended (task in-flight), these
# sub-allocations are never freed and appear as indirect leaks reachable only
# through the abandoned coroutine frame.
# ---------------------------------------------------------------------------
leak:chimaera::admin::Runtime::SendIn
