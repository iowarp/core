/*
 * Copyright (c) 2024, Gnosis Research Center, Illinois Institute of Technology
 * All rights reserved.
 *
 * This file is part of IOWarp Core.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * chimaera repo refresh - ChiMod Autogeneration Utility
 *
 * This utility automatically generates libexec source files (.cc) and methods
 * header files (.h) for ChiMods based on their chimaera_mod.yaml configuration files.
 *
 * The libexec source files implement Container virtual API methods (Run, Del,
 * SaveTask, LoadTask, AllocLoadTask, LocalLoadTask, LocalAllocLoadTask,
 * NewCopy, Aggregate) with switch-case dispatch.
 *
 * Usage:
 *     chimaera repo refresh <chimod_repo_path>
 */

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>

#include <yaml-cpp/yaml.h>
#include <hermes_shm/util/logging.h>

#include "chimaera_commands.h"

namespace fs = std::filesystem;

/**
 * Structure to hold method information
 */
struct Method {
  std::string constant_name;
  std::string method_name;
  int method_id;
  bool is_inherited;
};

/**
 * ChiMod Generator class
 * Handles generation of autogenerated files for ChiMods
 */
class ChiModGenerator {
 private:
  fs::path repo_path_;
  fs::path repo_yaml_path_;
  std::string repo_namespace_;

 public:
  explicit ChiModGenerator(const std::string& repo_path)
      : repo_path_(fs::absolute(repo_path)),
        repo_yaml_path_(repo_path_ / "chimaera_repo.yaml") {
    if (!fs::exists(repo_yaml_path_)) {
      throw std::runtime_error("Repository YAML not found: " + repo_yaml_path_.string());
    }

    // Load repository namespace from chimaera_repo.yaml
    YAML::Node repo_config = LoadRepoConfig();
    repo_namespace_ = repo_config["namespace"] ? repo_config["namespace"].as<std::string>() : "chimaera";
  }

  /**
   * Load the repository configuration
   */
  YAML::Node LoadRepoConfig() {
    try {
      return YAML::LoadFile(repo_yaml_path_.string());
    } catch (const YAML::Exception& e) {
      throw std::runtime_error("Failed to parse repository YAML: " + std::string(e.what()));
    }
  }

  /**
   * Load a specific ChiMod configuration
   */
  YAML::Node LoadChiModConfig(const std::string& chimod_name) {
    fs::path chimod_yaml_path = repo_path_ / chimod_name / "chimaera_mod.yaml";
    if (!fs::exists(chimod_yaml_path)) {
      throw std::runtime_error("ChiMod YAML not found: " + chimod_yaml_path.string());
    }

    try {
      return YAML::LoadFile(chimod_yaml_path.string());
    } catch (const YAML::Exception& e) {
      throw std::runtime_error("Failed to parse ChiMod YAML: " + std::string(e.what()));
    }
  }

  /**
   * Extract methods from configuration, filtering out those with value -1
   */
  std::vector<Method> GetMethods(const YAML::Node& config) {
    std::vector<Method> methods;

    // Process all key-value pairs in the config
    for (auto it = config.begin(); it != config.end(); ++it) {
      std::string key = it->first.as<std::string>();

      // Skip non-method keys
      if (key.length() == 0 || key[0] != 'k' || !it->second.IsScalar()) {
        continue;
      }

      // Try to parse as integer
      int value;
      try {
        value = it->second.as<int>();
      } catch (const YAML::Exception&) {
        continue; // Skip non-integer values
      }

      // Skip unimplemented methods (value -1)
      if (value == -1) {
        continue;
      }

      std::string method_name = key.substr(1); // Remove the 'k' prefix
      Method method;
      method.constant_name = key;
      method.method_name = method_name;
      method.method_id = value;
      method.is_inherited = value < 10;  // Inherited methods have IDs < 10
      methods.push_back(method);
    }

    // Sort by method ID
    std::sort(methods.begin(), methods.end(),
              [](const Method& a, const Method& b) {
                return a.method_id < b.method_id;
              });

    return methods;
  }

  /**
   * Generate the methods header file
   */
  std::string GenerateMethodsHeader(const std::string& chimod_name, const YAML::Node& config,
                                     const std::string& repo_namespace) {
    auto methods = GetMethods(config);
    std::string namespace_name = repo_namespace;
    std::string module_name = config["module_name"] ? config["module_name"].as<std::string>() : chimod_name;

    std::ostringstream oss;
    std::string chimod_upper;
    std::transform(chimod_name.begin(), chimod_name.end(), std::back_inserter(chimod_upper),
                   [](unsigned char c) { return std::toupper(c); });

    // Build namespace_upper for unique include guard
    std::string namespace_upper;
    std::transform(namespace_name.begin(), namespace_name.end(), std::back_inserter(namespace_upper),
                   [](unsigned char c) {
                     if (c == ':') return '_';
                     return (char)std::toupper(c);
                   });

    // Build the header content with unique include guard using namespace
    oss << "#ifndef " << namespace_upper << "_" << chimod_upper << "_AUTOGEN_METHODS_H_\n";
    oss << "#define " << namespace_upper << "_" << chimod_upper << "_AUTOGEN_METHODS_H_\n";
    oss << "\n";
    oss << "#include <chimaera/chimaera.h>\n";
    oss << "\n";
    oss << "/**\n";
    oss << " * Auto-generated method definitions for " << module_name << "\n";
    oss << " */\n";
    oss << "\n";
    oss << "namespace " << namespace_name << "::" << chimod_name << " {\n";
    oss << "\n";
    oss << "namespace Method {\n";

    // Add inherited methods
    std::vector<Method> inherited_methods;
    std::copy_if(methods.begin(), methods.end(), std::back_inserter(inherited_methods),
                 [](const Method& m) { return m.is_inherited; });

    if (!inherited_methods.empty()) {
      oss << "// Inherited methods\n";
      for (const auto& method : inherited_methods) {
        oss << "GLOBAL_CONST chi::u32 " << method.constant_name << " = " << method.method_id << ";\n";
      }
      oss << "\n";
    }

    // Add custom methods
    std::vector<Method> custom_methods;
    std::copy_if(methods.begin(), methods.end(), std::back_inserter(custom_methods),
                 [](const Method& m) { return !m.is_inherited; });

    if (!custom_methods.empty()) {
      oss << "// " << module_name << "-specific methods\n";
      for (const auto& method : custom_methods) {
        oss << "GLOBAL_CONST chi::u32 " << method.constant_name << " = " << method.method_id << ";\n";
      }
    }

    oss << "}  // namespace Method\n";
    oss << "\n";
    oss << "}  // namespace " << namespace_name << "::" << chimod_name << "\n";
    oss << "\n";
    oss << "#endif  // " << chimod_upper << "_AUTOGEN_METHODS_H_\n";

    return oss.str();
  }

  /**
   * Get the task type name for a method
   */
  std::string GetTaskTypeName(const std::string& method_name, const std::string& chimod_name) {
    // Special cases for common inherited methods
    if (method_name == "Create") {
      return "CreateTask";
    } else if (method_name == "Destroy") {
      return "DestroyTask";
    } else if (method_name.length() >= 11 && method_name.substr(0, 11) == "GetOrCreate") {
      // Template-based task
      return chimod_name + "::" + method_name + "Task<" + chimod_name + "::CreateParams>";
    }

    // Regular task (default case)
    return method_name + "Task";
  }

  /**
   * Generate the lib_exec source file (.cc) with Container virtual API implementations
   */
  std::string GenerateLibExecSource(const std::string& chimod_name, const YAML::Node& config,
                                     const std::string& repo_namespace) {
    auto methods = GetMethods(config);
    std::string namespace_name = repo_namespace;
    std::string module_name = config["module_name"] ? config["module_name"].as<std::string>() : chimod_name;

    std::ostringstream oss;

    // Build the source content
    oss << "/**\n";
    oss << " * Auto-generated execution implementation for " << module_name << " ChiMod\n";
    oss << " * Implements Container virtual APIs (Run, DelTask, SaveTask, LoadTask, NewCopyTask, NewTask, Aggregate)\n";
    oss << " * using switch-case dispatch\n";
    oss << " * \n";
    oss << " * This file is autogenerated - do not edit manually.\n";
    oss << " * Changes should be made to the autogen tool or the YAML configuration.\n";
    oss << " */\n";
    oss << "\n";
    oss << "#include \"" << namespace_name << "/" << module_name << "/" << chimod_name << "_runtime.h\"\n";
    oss << "#include \"" << namespace_name << "/" << module_name << "/autogen/" << chimod_name << "_methods.h\"\n";
    oss << "#include <chimaera/chimaera.h>\n";
    oss << "#include <chimaera/task.h>  // For TaskResume coroutine return type\n";
    oss << "\n";
    oss << "namespace " << namespace_name << "::" << chimod_name << " {\n";
    oss << "\n";
    oss << "//==============================================================================\n";
    oss << "// Container Virtual API Implementations\n";
    oss << "//==============================================================================\n";
    oss << "\n";
    oss << "void Runtime::Init(const chi::PoolId &pool_id, const std::string &pool_name,\n";
    oss << "                   chi::u32 container_id) {\n";
    oss << "  // Call base class initialization\n";
    oss << "  chi::Container::Init(pool_id, pool_name, container_id);\n";
    oss << "\n";
    oss << "  // Initialize the client for this ChiMod\n";
    oss << "  client_ = Client(pool_id);\n";
    oss << "}\n";
    oss << "\n";
    oss << "chi::TaskResume Runtime::Run(chi::u32 method, hipc::FullPtr<chi::Task> task_ptr, chi::RunContext& rctx) {\n";
    oss << "  switch (method) {\n";

    // Add Run switch cases for each method
    // All method calls use co_await since Run is a coroutine and methods
    // may return TaskResume (coroutines). Methods returning void are wrapped
    // to be awaitable. This ensures coroutines actually execute rather than
    // being discarded when the return value is ignored.
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      // Cast task FullPtr to specific type\n";
      oss << "      hipc::FullPtr<" << task_type << "> typed_task = task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      co_await " << method.method_name << "(typed_task, rctx);\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // Unknown method - do nothing\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "  // co_return makes this a coroutine returning TaskResume\n";
    oss << "  co_return;\n";
    oss << "}\n";
    oss << "\n";
    oss << "void Runtime::DelTask(chi::u32 method, hipc::FullPtr<chi::Task> task_ptr) {\n";
    oss << "  // Use IPC manager to deallocate task from private memory\n";
    oss << "  auto* ipc_manager = CHI_IPC;\n";
    oss << "  \n";
    oss << "  switch (method) {\n";

    // Add Del switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      ipc_manager->DelTask(task_ptr.template Cast<" << task_type << ">());\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // For unknown methods, still try to delete from main segment\n";
    oss << "      ipc_manager->DelTask(task_ptr);\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "void Runtime::SaveTask(chi::u32 method, chi::SaveTaskArchive& archive, \n";
    oss << "                        hipc::FullPtr<chi::Task> task_ptr) {\n";
    oss << "  switch (method) {\n";

    // Add SaveTask switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      auto typed_task = task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      archive << *typed_task.ptr_;\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // Unknown method - do nothing\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "void Runtime::LoadTask(chi::u32 method, chi::LoadTaskArchive& archive,\n";
    oss << "                        hipc::FullPtr<chi::Task> task_ptr) {\n";
    oss << "  switch (method) {\n";

    // Add LoadTask switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      auto typed_task = task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      archive >> *typed_task.ptr_;\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // Unknown method - do nothing\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "hipc::FullPtr<chi::Task> Runtime::AllocLoadTask(chi::u32 method, chi::LoadTaskArchive& archive) {\n";
    oss << "  hipc::FullPtr<chi::Task> task_ptr = NewTask(method);\n";
    oss << "  if (!task_ptr.IsNull()) {\n";
    oss << "    LoadTask(method, archive, task_ptr);\n";
    oss << "  }\n";
    oss << "  return task_ptr;\n";
    oss << "}\n";
    oss << "\n";
    oss << "void Runtime::LocalLoadTask(chi::u32 method, chi::LocalLoadTaskArchive& archive,\n";
    oss << "                            hipc::FullPtr<chi::Task> task_ptr) {\n";
    oss << "  switch (method) {\n";

    // Add LocalLoadTask switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      auto typed_task = task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      // Use archive operator which respects msg_type\n";
      oss << "      archive >> *typed_task.ptr_;\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // Unknown method - do nothing\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "hipc::FullPtr<chi::Task> Runtime::LocalAllocLoadTask(chi::u32 method, chi::LocalLoadTaskArchive& archive) {\n";
    oss << "  hipc::FullPtr<chi::Task> task_ptr = NewTask(method);\n";
    oss << "  if (!task_ptr.IsNull()) {\n";
    oss << "    LocalLoadTask(method, archive, task_ptr);\n";
    oss << "  }\n";
    oss << "  return task_ptr;\n";
    oss << "}\n";
    oss << "\n";
    oss << "void Runtime::LocalSaveTask(chi::u32 method, chi::LocalSaveTaskArchive& archive, \n";
    oss << "                             hipc::FullPtr<chi::Task> task_ptr) {\n";
    oss << "  switch (method) {\n";

    // Add LocalSaveTask switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      auto typed_task = task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      // Use archive operator which respects msg_type\n";
      oss << "      archive << *typed_task.ptr_;\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // Unknown method - do nothing\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "hipc::FullPtr<chi::Task> Runtime::NewCopyTask(chi::u32 method, hipc::FullPtr<chi::Task> orig_task_ptr, bool deep) {\n";
    oss << "  auto* ipc_manager = CHI_IPC;\n";
    oss << "  if (!ipc_manager) {\n";
    oss << "    return hipc::FullPtr<chi::Task>();\n";
    oss << "  }\n";
    oss << "  \n";
    oss << "  switch (method) {\n";

    // Add NewCopyTask switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      // Allocate new task\n";
      oss << "      auto new_task_ptr = ipc_manager->NewTask<" << task_type << ">();\n";
      oss << "      if (!new_task_ptr.IsNull()) {\n";
      oss << "        // Copy task fields (includes base Task fields)\n";
      oss << "        auto task_typed = orig_task_ptr.template Cast<" << task_type << ">();\n";
      oss << "        new_task_ptr->Copy(task_typed);\n";
      oss << "        return new_task_ptr.template Cast<chi::Task>();\n";
      oss << "      }\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // For unknown methods, create base Task copy\n";
      oss << "      auto new_task_ptr = ipc_manager->NewTask<chi::Task>();\n";
    oss << "      if (!new_task_ptr.IsNull()) {\n";
    oss << "        new_task_ptr->Copy(orig_task_ptr);\n";
    oss << "        return new_task_ptr;\n";
    oss << "      }\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "  \n";
    oss << "  (void)deep;    // Deep copy parameter reserved for future use\n";
    oss << "  return hipc::FullPtr<chi::Task>();\n";
    oss << "}\n";
    oss << "\n";
    oss << "hipc::FullPtr<chi::Task> Runtime::NewTask(chi::u32 method) {\n";
    oss << "  auto* ipc_manager = CHI_IPC;\n";
    oss << "  if (!ipc_manager) {\n";
    oss << "    return hipc::FullPtr<chi::Task>();\n";
    oss << "  }\n";
    oss << "  \n";
    oss << "  switch (method) {\n";

    // Add NewTask switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      auto new_task_ptr = ipc_manager->NewTask<" << task_type << ">();\n";
      oss << "      return new_task_ptr.template Cast<chi::Task>();\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // For unknown methods, return null pointer\n";
    oss << "      return hipc::FullPtr<chi::Task>();\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "void Runtime::Aggregate(chi::u32 method, hipc::FullPtr<chi::Task> origin_task_ptr,\n";
    oss << "                         hipc::FullPtr<chi::Task> replica_task_ptr) {\n";
    oss << "  switch (method) {\n";

    // Add Aggregate switch cases
    for (const auto& method : methods) {
      std::string task_type = GetTaskTypeName(method.method_name, chimod_name);
      oss << "    case Method::" << method.constant_name << ": {\n";
      oss << "      // Get typed tasks for Aggregate call\n";
      oss << "      auto typed_origin = origin_task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      auto typed_replica = replica_task_ptr.template Cast<" << task_type << ">();\n";
      oss << "      // Call Aggregate (uses task-specific Aggregate if available, otherwise base Task::Aggregate)\n";
      oss << "      typed_origin.ptr_->Aggregate(typed_replica);\n";
      oss << "      break;\n";
      oss << "    }\n";
    }

    oss << "    default: {\n";
    oss << "      // For unknown methods, use base Task Aggregate (which also propagates return codes)\n";
    oss << "      origin_task_ptr.ptr_->Aggregate(replica_task_ptr);\n";
    oss << "      break;\n";
    oss << "    }\n";
    oss << "  }\n";
    oss << "}\n";
    oss << "\n";
    oss << "} // namespace " << namespace_name << "::" << chimod_name << "\n";

    return oss.str();
  }

  /**
   * Generate autogen files for a single ChiMod
   */
  void GenerateChiModFiles(const std::string& chimod_name) {
    HIPRINT("Generating files for ChiMod: {}", chimod_name);

    // Load ChiMod configuration
    YAML::Node config;
    try {
      config = LoadChiModConfig(chimod_name);
    } catch (const std::runtime_error& e) {
      HLOG(kWarning, "{}", e.what());
      return;
    }

    // Create include autogen directory for methods header
    // Structure: [chimod_directory]/include/[namespace]/[module_name]/autogen/
    std::string module_name = config["module_name"] ? config["module_name"].as<std::string>() : chimod_name;
    fs::path include_autogen_dir = repo_path_ / chimod_name / "include" / repo_namespace_ / module_name / "autogen";
    fs::create_directories(include_autogen_dir);

    // Create src autogen directory for lib_exec source
    fs::path src_autogen_dir = repo_path_ / chimod_name / "src" / "autogen";
    fs::create_directories(src_autogen_dir);

    // Generate methods header
    std::string methods_content = GenerateMethodsHeader(chimod_name, config, repo_namespace_);
    fs::path methods_file = include_autogen_dir / (chimod_name + "_methods.h");
    std::ofstream methods_stream(methods_file);
    if (!methods_stream) {
      throw std::runtime_error("Failed to create methods file: " + methods_file.string());
    }
    methods_stream << methods_content;
    methods_stream.close();
    HIPRINT("  Generated: {}", methods_file.string());

    // Generate lib_exec source file
    std::string lib_exec_content = GenerateLibExecSource(chimod_name, config, repo_namespace_);
    fs::path lib_exec_file = src_autogen_dir / (chimod_name + "_lib_exec.cc");
    std::ofstream lib_exec_stream(lib_exec_file);
    if (!lib_exec_stream) {
      throw std::runtime_error("Failed to create lib_exec file: " + lib_exec_file.string());
    }
    lib_exec_stream << lib_exec_content;
    lib_exec_stream.close();
    HIPRINT("  Generated: {}", lib_exec_file.string());
  }

  /**
   * Refresh all ChiMods in the repository
   */
  void DoRefreshRepo() {
    YAML::Node repo_config = LoadRepoConfig();

    if (!repo_config["modules"] || !repo_config["modules"].IsSequence()) {
      throw std::runtime_error("No modules found in repository configuration");
    }

    std::vector<std::string> modules;
    for (const auto& module : repo_config["modules"]) {
      modules.push_back(module.as<std::string>());
    }

    HIPRINT("Refreshing ChiMod repository: {}", repo_path_.string());
    std::string module_list;
    for (size_t i = 0; i < modules.size(); ++i) {
      if (i > 0) module_list += ", ";
      module_list += modules[i];
    }
    HIPRINT("Found {} modules: {}", modules.size(), module_list);
    HIPRINT("");

    for (const auto& chimod_name : modules) {
      GenerateChiModFiles(chimod_name);
      HIPRINT("");
    }

    HIPRINT("Repository refresh complete!");
  }
};

/**
 * Print usage information for the repo refresh subcommand
 *
 * @param program_name The name of the program for display
 */
static void PrintRefreshRepoUsage(const char* program_name) {
  HIPRINT("Usage: {} <chimod_repo_path>", program_name);
  HIPRINT("");
  HIPRINT("Autogenerate ChiMod libexec and methods files");
  HIPRINT("");
  HIPRINT("Examples:");
  HIPRINT("  {} /path/to/chimods", program_name);
  HIPRINT("  {} .", program_name);
}

/**
 * Entry point for the repo refresh subcommand
 *
 * @param argc Argument count (after stripping "chimaera repo refresh")
 * @param argv Argument values
 * @return 0 on success, 1 on failure
 */
int RefreshRepo(int argc, char** argv) {
  if (argc != 1) {
    PrintRefreshRepoUsage("chimaera repo refresh");
    return 1;
  }

  std::string repo_path = argv[0];

  try {
    ChiModGenerator generator(repo_path);
    generator.DoRefreshRepo();
    return 0;
  } catch (const std::exception& e) {
    HLOG(kError, "{}", e.what());
    return 1;
  }
}
